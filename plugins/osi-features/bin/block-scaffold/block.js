#!/usr/bin/env node
/* eslint-disable no-console */

/**
 * External dependencies
 */
const fs = require( 'fs' );
const path = require( 'path' );

const readline = require( 'readline' );

const rl = readline.createInterface( {
	input: process.stdin,
	output: process.stdout,
} );

const info = {
	error: ( message ) => {
		return `\x1b[31m${ message }\x1b[0m`;
	},
	success: ( message ) => {
		return `\x1b[32m${ message }\x1b[0m`;
	},
	warning: ( message ) => {
		return `\x1b[33m${ message }\x1b[0m`;
	},
	message: ( message ) => {
		return `\x1b[34m${ message }\x1b[0m`;
	},
};

// Questions to ask.
const questions = {
	blockTitle: {
		question: '\nThe display title for your block',
		default: 'Example Static',
	},
	blockSlug: {
		question: 'The block slug used for identification',
		default: 'example-static',
	},
	blockNamespace: {
		question: 'The internal namespace for the block',
		default: 'example-static-internal',
	},
	textDomain: {
		question: 'The text domain for the block',
		default: 'example-static',
	},
	blockDescription: {
		question: 'The short description for the block (optional)',
		default: 'Example static block generated by features plugin Create Block Scaffold.',
	},
	blockDashIcon: {
		question: 'The dashicon for the block (optional)',
		default: 'smiley',
	},
	blockCategory: {
		question: `The category for the block:\n${ info.message( '1. text\n2. media\n3. embed\n4. design\n5. theme' ) }\nEnter the number`,
		default: 1,
		options: {
			1: 'text',
			2: 'media',
			3: 'embed',
			4: 'design',
			5: 'theme',
		},
	},
};

const init = () => {
	rl.question( `\nWhat type of block would you like to create?\n${ info.message( '1. Static Block\n2. Dynamic Block\n3. Meta Block' ) }\nEnter you choice: `, async ( option ) => {
		switch ( parseInt( option, 10 ) ) {
			case 1:
				await generateBlock( 'static-block', 'static block' );
				rl.close();
				break;
			case 2:
				await generateBlock( 'dynamic-block', 'dynamic block' );
				rl.close();
				break;
			case 3:
				await generateBlock( 'meta-block', 'meta block' );
				rl.close();
				break;
			default:
				console.log( info.error( '\nYou must enter a valid option' ) );
				init();
		}
	} );
};

/**
 * Generate questions based on the passed arguments.
 *
 * @param {string} question      Question to ask.
 * @param {string} defaultAnswer Default answer.
 * @return {Promise}        Promise object contains the answer or default answer.
 */
const generateQuestion = ( question, defaultAnswer ) => {
	return new Promise( ( resolve ) => {
		rl.question( question, ( answer ) => {
			if ( ! answer ) {
				rl.write( `${ info.success( defaultAnswer ) }\n` );
				resolve( defaultAnswer );
			}
			resolve( answer );
		} );
	} );
};

/**
 * Generate block based on the passed arguments.
 *
 * @param {string} blockDir  Block directory.
 * @param {string} blockType Block type.
 */
const generateBlock = async ( blockDir, blockType ) => {
	const blockData = await askAllQuestions();
	const chunksToReplace = {
		'{{title}}': blockData.blockTitle,
		'{{textdomain}}': blockData.textDomain,
		'{{slug}}': blockData.blockSlug,
		'{{namespace}}': blockData.blockNamespace,
	};

	if ( 'meta block' === blockType ) {
		chunksToReplace[ '{{metaBlockKey}}' ] = `${ blockData.blockTitle.replace( /\s+/g, '_' ).toLowerCase() }_meta_block_field`;
	}

	console.log( info.message( `\nGenerating ${ blockType } ${ info.warning( blockData.blockTitle ) }...\n` ) );
	const templateFiles = getBlockTemplateFiles( blockDir );
	const newBlockDir = copyTemplateFiles( blockData.blockSlug, 'meta block' === blockType ? getMetaBlocksDir() : getBlocksDir(), templateFiles );
	runSearchReplace( newBlockDir, chunksToReplace );
	generateBlockJSONFile( newBlockDir, blockData );
	finalMessage( blockData.blockTitle );
};

/**
 * Ask all questions in a CLI interface.
 *
 * @return {Promise} Promise object contains answers for all questions.
 */
const askAllQuestions = async () => {
	const answers = {};
	for ( const question in questions ) {
		if ( questions.hasOwnProperty( question ) ) {
			answers[ question ] = await generateQuestion( `${ questions[ question ].question } (${ info.message( questions[ question ].default ) }):`, questions[ question ].default );
		}
	}
	answers.blockCategory = questions.blockCategory.options[ answers.blockCategory ] ? questions.blockCategory.options[ answers.blockCategory ] : 'text';
	return answers;
};

/**
 * Get block template files.
 *
 * @param {string} blockDirName Block directory name which contains the template files.
 * @return {Array}         Array of template files.
 */
const getBlockTemplateFiles = ( blockDirName ) => {
	try {
		const blockPath = path.resolve( __dirname, `../../bin/block-scaffold/templates/${ blockDirName }` );
		return fs.readdirSync( blockPath ).map( ( file ) => {
			return path.resolve( blockPath, file );
		} ).filter( ( file ) => {
			return fs.statSync( file ).isFile() && path.extname( file ) === '.mustache';
		} );
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Copy template files to the new block directory.
 *
 * @param {string} blockDirName New block directory name.
 * @param {string} blockPath    Path where blocks are located.
 * @param {Array}  blockFiles   Array of template files.
 * @return {string}        Path of the new block directory.
 */
const copyTemplateFiles = ( blockDirName, blockPath, blockFiles ) => {
	try {
		const blockDir = `${ blockPath }/${ blockDirName }`;
		if ( ! fs.existsSync( blockDir ) ) {
			fs.mkdirSync( blockDir );
		}
		for ( const file of blockFiles ) {
			const fileName = path.basename( file, '.mustache' );
			const filePath = `${ blockDir }/${ fileName }`;
			if ( ! fs.existsSync( filePath ) ) {
				fs.copyFileSync( file, filePath );
			}
		}
		return blockDir;
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Get block directory path where all blocks are located.
 *
 * @return {string} Path of the blocks directory.
 */
const getBlocksDir = () => {
	try {
		const blocksDir = path.resolve( __dirname, '../../assets/src/blocks' );
		if ( ! fs.existsSync( blocksDir ) ) {
			fs.mkdirSync( blocksDir );
		}
		return blocksDir;
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Get meta block directory path where all meta blocks are located.
 *
 * @return {string} Path of the meta blocks directory.
 */
const getMetaBlocksDir = () => {
	try {
		const metaBlocksDir = path.resolve( __dirname, '../../assets/src/blocks/meta-blocks' );
		if ( ! fs.existsSync( metaBlocksDir ) ) {
			fs.mkdirSync( metaBlocksDir );
		}
		return metaBlocksDir;
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Generate block JSON file which used to register the block.
 *
 * @param {string}  blockPath Path of the new block directory.
 * @param {Object}  blockData Block data e.g. title, slug, textdomain, namespace.
 * @param {boolean} metaBlock Flag to indicate if the block is a meta block.
 */
const generateBlockJSONFile = async ( blockPath, blockData, metaBlock = false ) => {
	const blockJson = {
		$schema: 'https://schemas.wp.org/trunk/block.json',
		apiVersion: 2,
		name: `${ blockData.blockNamespace }/${ blockData.blockSlug }`,
		version: '1.0.0',
		title: blockData.blockTitle,
		category: blockData.blockCategory,
		icon: blockData.blockDashIcon,
		description: blockData.blockDescription,
		supports: {
			html: false,
		},
		attributes: {},
		textdomain: blockData.textDomain,
		editorScript: 'file:./index.js',
		editorStyle: 'file:./index.css',
		style: 'file:./style-index.css',
	};

	if ( metaBlock ) {
		delete blockJson.editorStyle;
		delete blockJson.style;
	}

	try {
		fs.writeFileSync( `${ blockPath }/block.json`, JSON.stringify( blockJson, null, 2 ) );
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Run search-replace command to replace the placeholder text with the actual value.
 *
 * @param {string} blockDir Path of the new block directory.
 * @param {Object} data     Block data e.g. title, slug, textdomain, namespace.
 */
const runSearchReplace = ( blockDir, data ) => {
	try {
		const blockFiles = fs.readdirSync( blockDir );
		blockFiles.forEach( ( file ) => {
			const filePath = `${ blockDir }/${ file }`;
			if ( fs.statSync( filePath ).isFile() ) {
				Object.keys( data ).forEach( ( key ) => {
					const regex = new RegExp( key, 'g' );
					const fileContent = fs.readFileSync( filePath, 'utf8' );
					const newFileContent = fileContent.replace( regex, data[ key ] );
					fs.writeFileSync( filePath, newFileContent );
				} );
			}
		} );
	} catch ( err ) {
		console.log( info.error( err ) );
		process.exit( 0 );
	}
};

/**
 * Print a final message to the console with the block details and next steps.
 *
 * @param {string}  blockName Name of the block.
 * @param {boolean} metaBlock Flag to indicate if the block is a meta block.
 */
const finalMessage = ( blockName, metaBlock = false ) => {
	console.log( info.success( `Block ${ blockName } created successfully!\n` ) );
	console.log( info.message( 'Next steps:' ) );
	if ( metaBlock ) {
		console.log( info.message( '1. Add the meta block to the \'inc/classes/class-meta-blocks.php\' file.' ) );
	} else {
		console.log( info.message( '1. Add the block to the \'inc/classes/class-blocks.php\' file.' ) );
	}
	console.log( info.message( `2. Add webpack entry for the block's JS file.` ) );
};

rl.on( 'close', () => {
	process.exit( 0 );
} );

/* eslint-enable no-console */

// Init
init();
